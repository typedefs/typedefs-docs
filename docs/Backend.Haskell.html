<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>IdrisDoc: Backend.Haskell</title><link type="text/css" rel="stylesheet" href="../styles.css"></head><body class="namespace"><div class="wrapper"><header><strong>IdrisDoc</strong>: Backend.Haskell<nav><a href="../index.html">Index</a></nav></header><div class="container"><h1>Backend.Haskell</h1><dl class="decls"><dt id="Backend.Haskell.Haskell"><span class="word">data&nbsp;</span><span class="name type" title="Backend.Haskell.Haskell">Haskell</span><span class="word">&nbsp;:&nbsp;</span><span class="signature"><span class="type" title="Type">Type</span></span></dt><dd><p>The syntactic structure of Haskell type declarations.</p>
<dl class="decls"><dt id="Backend.Haskell.Synonym"><span class="name constructor" title="Backend.Haskell.Synonym">Synonym</span><span class="word">&nbsp;:&nbsp;</span><span class="signature"><a class="type" title="Backend.Decl" href="Backend.html#Backend.Decl">Decl</a> ->
<a class="type" title="Backend.Haskell.HsType" href="Backend.Haskell.html#Backend.Haskell.HsType">HsType</a> ->
<a class="type" title="Backend.Haskell.Haskell" href="Backend.Haskell.html#Backend.Haskell.Haskell">Haskell</a></span></dt><dd><p>A type synonym is a declared name (possibly with parameters) and a type.</p>
</dd><dt id="Backend.Haskell.ADT"><span class="name constructor" title="Backend.Haskell.ADT">ADT</span><span class="word">&nbsp;:&nbsp;</span><span class="signature"><a class="type" title="Backend.Decl" href="Backend.html#Backend.Decl">Decl</a> ->
<a class="type" title="Data.Vect.Vect" href="Data.Vect.html#Data.Vect.Vect">Vect</a> <span class="implicit boundvar" title="">n</span>
<a class="type" title="Builtins.Pair" href="Builtins.html#Builtins.Pair">(</a><a class="function" title="Types.Name" href="Types.html#Types.Name">Name</a><a class="type" title="Builtins.Pair" href="Builtins.html#Builtins.Pair">,</a>
<a class="type" title="Backend.Haskell.HsType" href="Backend.Haskell.html#Backend.Haskell.HsType">HsType</a><a class="type" title="Builtins.Pair" href="Builtins.html#Builtins.Pair">)</a> ->
<a class="type" title="Backend.Haskell.Haskell" href="Backend.Haskell.html#Backend.Haskell.Haskell">Haskell</a></span></dt><dd><p>An algebraic data type is a declared name (possibly with parameters)<br />
and a number of constructors, each wrapping a Haskell type.</p>
</dd></dl></dd><dt id="Backend.Haskell.HsType"><span class="word">data&nbsp;</span><span class="name type" title="Backend.Haskell.HsType">HsType</span><span class="word">&nbsp;:&nbsp;</span><span class="signature"><span class="type" title="Type">Type</span></span></dt><dd><p>The syntactic structure of Haskell types.</p>
<dl class="decls"><dt id="Backend.Haskell.HsVoid"><span class="name constructor" title="Backend.Haskell.HsVoid">HsVoid</span><span class="word">&nbsp;:&nbsp;</span><span class="signature"><a class="type" title="Backend.Haskell.HsType" href="Backend.Haskell.html#Backend.Haskell.HsType">HsType</a></span></dt><dd><p>The <code>Void</code> (i.e. empty) type.</p>
</dd><dt id="Backend.Haskell.HsUnit"><span class="name constructor" title="Backend.Haskell.HsUnit">HsUnit</span><span class="word">&nbsp;:&nbsp;</span><span class="signature"><a class="type" title="Backend.Haskell.HsType" href="Backend.Haskell.html#Backend.Haskell.HsType">HsType</a></span></dt><dd><p>The <code>()</code> (i.e. unit/singleton) type.</p>
</dd><dt id="Backend.Haskell.HsTuple"><span class="name constructor" title="Backend.Haskell.HsTuple">HsTuple</span><span class="word">&nbsp;:&nbsp;</span><span class="signature"><a class="type" title="Data.Vect.Vect" href="Data.Vect.html#Data.Vect.Vect">Vect</a> (<a class="function" title="Prelude.Interfaces.fromInteger" href="Prelude.Interfaces.html#Prelude.Interfaces.fromInteger">fromInteger</a> <span class="data" title="2">2</span> <a class="function" title="Prelude.Interfaces.+" href="Prelude.Interfaces.html#Prelude.Interfaces.+">+</a>
<span class="implicit boundvar" title="">n</span>)
<a class="type" title="Backend.Haskell.HsType" href="Backend.Haskell.html#Backend.Haskell.HsType">HsType</a> ->
<a class="type" title="Backend.Haskell.HsType" href="Backend.Haskell.html#Backend.Haskell.HsType">HsType</a></span></dt><dd><p>The tuple type, containing two or more further types.</p>
</dd><dt id="Backend.Haskell.HsVar"><span class="name constructor" title="Backend.Haskell.HsVar">HsVar</span><span class="word">&nbsp;:&nbsp;</span><span class="signature"><a class="function" title="Types.Name" href="Types.html#Types.Name">Name</a> ->
<a class="type" title="Backend.Haskell.HsType" href="Backend.Haskell.html#Backend.Haskell.HsType">HsType</a></span></dt><dd><p>A type variable.</p>
</dd><dt id="Backend.Haskell.HsParam"><span class="name constructor" title="Backend.Haskell.HsParam">HsParam</span><span class="word">&nbsp;:&nbsp;</span><span class="signature"><a class="function" title="Types.Name" href="Types.html#Types.Name">Name</a> ->
<a class="type" title="Data.Vect.Vect" href="Data.Vect.html#Data.Vect.Vect">Vect</a> <span class="implicit boundvar" title="">n</span>
<a class="type" title="Backend.Haskell.HsType" href="Backend.Haskell.html#Backend.Haskell.HsType">HsType</a> ->
<a class="type" title="Backend.Haskell.HsType" href="Backend.Haskell.html#Backend.Haskell.HsType">HsType</a></span></dt><dd><p>A named type with zero or more other types as parameters.</p>
</dd></dl></dd><dt id="Backend.Haskell.generateType"><span class="name function" title="Backend.Haskell.generateType">generateType</span><span class="word">&nbsp;:&nbsp;</span><span class="signature"><a class="type" title="Typedefs.TDef" href="Typedefs.html#Typedefs.TDef">TDef</a> <span class="implicit boundvar" title="">n</span> ->
<a class="type" title="Text.PrettyPrint.WL.Core.Doc" href="Text.PrettyPrint.WL.Core.html#Text.PrettyPrint.WL.Core.Doc">Doc</a></span></dt><dd><p>Generate type body, only useful for anonymous tdefs (i.e. without wrapping Mu/Name)</p>
</dd><dt id="Backend.Haskell.guardParen"><span class="name function" title="Backend.Haskell.guardParen">guardParen</span><span class="word">&nbsp;:&nbsp;</span><span class="signature"><a class="type" title="Backend.Haskell.HsType" href="Backend.Haskell.html#Backend.Haskell.HsType">HsType</a> ->
<a class="type" title="Text.PrettyPrint.WL.Core.Doc" href="Text.PrettyPrint.WL.Core.html#Text.PrettyPrint.WL.Core.Doc">Doc</a></span></dt><dd><p>As <code>renderType</code>, but with enclosing top-level parentheses<br />
if it can possibly make a semantic difference.</p>
</dd><dt id="Backend.Haskell.makeDefs"><span class="name function" title="Backend.Haskell.makeDefs">makeDefs</span><span class="word">&nbsp;:&nbsp;</span><span class="signature"><a class="function" title="Backend.Env" href="Backend.html#Backend.Env">Env</a> <span class="implicit boundvar" title="">n</span> ->
<a class="type" title="Typedefs.TDef" href="Typedefs.html#Typedefs.TDef">TDef</a> <span class="implicit boundvar" title="">n</span> ->
<a class="function" title="Control.Monad.State.State" href="Control.Monad.State.html#Control.Monad.State.State">State</a> (<a class="type" title="Prelude.List.List" href="Prelude.List.html#Prelude.List.List">List</a> <a class="function" title="Types.Name" href="Types.html#Types.Name">Name</a>)
(<a class="type" title="Prelude.List.List" href="Prelude.List.html#Prelude.List.List">List</a> <a class="type" title="Backend.Haskell.Haskell" href="Backend.Haskell.html#Backend.Haskell.Haskell">Haskell</a>)</span></dt><dd><p>Generate Haskell type definitions from a <code>TDef</code>, including all of its dependencies.</p>
</dd><dt id="Backend.Haskell.makeType"><span class="name function" title="Backend.Haskell.makeType">makeType</span><span class="word">&nbsp;:&nbsp;</span><span class="signature"><a class="function" title="Backend.Env" href="Backend.html#Backend.Env">Env</a> <span class="implicit boundvar" title="">n</span> ->
<a class="type" title="Typedefs.TDef" href="Typedefs.html#Typedefs.TDef">TDef</a> <span class="implicit boundvar" title="">n</span> ->
<a class="type" title="Backend.Haskell.HsType" href="Backend.Haskell.html#Backend.Haskell.HsType">HsType</a></span></dt><dd><p>Generate a Haskell type from a <code>TDef</code>.</p>
</dd><dt id="Backend.Haskell.renderApp"><span class="name function" title="Backend.Haskell.renderApp">renderApp</span><span class="word">&nbsp;:&nbsp;</span><span class="signature"><a class="function" title="Types.Name" href="Types.html#Types.Name">Name</a> ->
<a class="type" title="Data.Vect.Vect" href="Data.Vect.html#Data.Vect.Vect">Vect</a> <span class="implicit boundvar" title="">n</span>
<a class="type" title="Text.PrettyPrint.WL.Core.Doc" href="Text.PrettyPrint.WL.Core.html#Text.PrettyPrint.WL.Core.Doc">Doc</a> ->
<a class="type" title="Text.PrettyPrint.WL.Core.Doc" href="Text.PrettyPrint.WL.Core.html#Text.PrettyPrint.WL.Core.Doc">Doc</a></span></dt><dd><p>Render a name applied to a list of arguments exactly as written.<br />
Arguments need to be previously parenthesized, if applicable.</p>
</dd><dt id="Backend.Haskell.renderDecl"><span class="name function" title="Backend.Haskell.renderDecl">renderDecl</span><span class="word">&nbsp;:&nbsp;</span><span class="signature"><a class="type" title="Backend.Decl" href="Backend.html#Backend.Decl">Decl</a> ->
<a class="type" title="Text.PrettyPrint.WL.Core.Doc" href="Text.PrettyPrint.WL.Core.html#Text.PrettyPrint.WL.Core.Doc">Doc</a></span></dt><dd><p>Helper function to render a top-level declaration as source code.</p>
</dd><dt id="Backend.Haskell.renderDef"><span class="name function" title="Backend.Haskell.renderDef">renderDef</span><span class="word">&nbsp;:&nbsp;</span><span class="signature"><a class="type" title="Backend.Haskell.Haskell" href="Backend.Haskell.html#Backend.Haskell.Haskell">Haskell</a> ->
<a class="type" title="Text.PrettyPrint.WL.Core.Doc" href="Text.PrettyPrint.WL.Core.html#Text.PrettyPrint.WL.Core.Doc">Doc</a></span></dt><dd><p>Render a type definition as Haskell source code.</p>
</dd><dt id="Backend.Haskell.renderType"><span class="name function" title="Backend.Haskell.renderType">renderType</span><span class="word">&nbsp;:&nbsp;</span><span class="signature"><a class="type" title="Backend.Haskell.HsType" href="Backend.Haskell.html#Backend.Haskell.HsType">HsType</a> ->
<a class="type" title="Text.PrettyPrint.WL.Core.Doc" href="Text.PrettyPrint.WL.Core.html#Text.PrettyPrint.WL.Core.Doc">Doc</a></span></dt><dd><p>Render a type signature as Haskell source code.</p>
</dd></dl></div></div><footer>Produced by IdrisDoc version 1.0</footer></body></html>